DBussy is yet another Python binding for accessing D-Bus
<https://www.freedesktop.org/wiki/Software/dbus/>. I know there is
already dbus-python <http://dbus.freedesktop.org/doc/dbus-python/>,
among others
<https://www.freedesktop.org/wiki/Software/DBusBindings/>. So why do
we need another one?

The main issue is one of event loops. Most of the existing bindings
seem to be based around GLib. However, Python now has its own
“asyncio” event-loop architecture
<https://docs.python.org/3/library/asyncio.html>. This goes back to
Python 3.4, but as of 3.5, you now have full-fledged coroutines
(“async def” and “await”) as a language feature.

Every GUI toolkit already provides its own event loop; so why did
the Python developers decide to add yet another one? The answer
seems clear: to provide a language-standard API for event loops,
and a reference implementation for this API. It should be possible
to adapt other event loops to this same API, and then Python
code written to work with asyncio becomes event-loop agnostic.


What Is D-Bus?
==============

D-Bus is a high-level interprocess communication protocol. It also
provides a standard daemon, that is included with the main Linux
desktop environments, that implements a set of standard “buses”: a
“system” bus that is created at system boot time, and a “session” bus
that belongs to each user who logs into one of these desktop
environments.

Processes can register their services on one of these buses--the
system bus for systemwide access, or the session bus for per-user
access--where other processes can find them by name and connect to
them. Or they can accept connections on entirely separate networking
sockets, without any dependency on the D-Bus daemon. libdbus, the
reference implementation for the low-level D-Bus protocol, supports
both modes of operation.

D-Bus is based around the concept of passing messages conforming to
a standard, extensible format. Messages are of four types:
  * a “method call”
  * a “method return” (normal response to a method call)
  * an “error” (abnormal response to a method call)
  * a “signal” notification

A method-call message is how one process requests a service of another
process via D-Bus; the usual response would be a method-return message
in the other direction indicating the completion status of the service
being performed; it is also possible to send method-call messages
without expecting a reply. If there was something wrong with the
method-call message (e.g. inappropriate parameters, lack of
permissions), then the response would be an error message. One could
also send a method-return with information indicating a failure to
perform the requested service; presumably the choice between the types
of response is that an error return indicates a condition that is not
supposed to happen--a bug in the requesting program.

Signal messages are sent as notifications of interesting events
pertaining to the current session (for the session bus) or the entire
system (for the system bus). They are usually not sent to a specific
destination, but can be picked up by all interested processes on the
bus. There are no replies to signals; if the receiving process cannot
or will not process a particular message, it simply ignores it.

D-Bus also includes an extensive type system for encoding data in a
message. A message contains a sequence of 0, 1 or more parameters,
each of which can be of various types: “basic” types (e.g. integer,
float, string) or “container” types (structs, arrays, dictionaries)
which in turn contain more values, each of which in turn can be of a
basic or (recursively) another container type. A “signature” is a
string encoding the type of a value, or sequence of values; there is
also a “variant” type, which means the type of the value is encoded
dynamically with the value itself, separate from the signature.

The importance of type signatures is really up to the particular
programs that are trying to communicate: some might insist on values
exactly matching the expected type signature, whereas others might be
more lenient. For example, while the D-Bus type system specifies
different basic types for different sizes of integers of signed or
unsigned varieties, most Python code will probably not care about the
specific distinctions, and treat all these values as of type “int”.


Enter DBussy
============

DBussy allows you to take advantage of asyncio, but it doesn’t force
you to use it. DBussy is meant to give you access to (nearly) all the
functionality of the underlying libdbus library
<https://dbus.freedesktop.org/doc/api/html/index.html>. libdbus is a
very low-level, very general library, designed to be called from C
code, that makes no assumptions about event loops at all. Consider the
basic task in a client program of sending a D-Bus request message and
waiting for a reply; or consider a server waiting for a message to
come in. libdbus offers 3 different ways to handle this:

  * poll repeatedly until the message appears
  * block the thread until the message comes in
  * specify a callback to be notified when the message is available

DBussy offers access to all these ways. But it also gives you the
option of engaging the asyncio event loop. This means you can be doing
other things in the loop, and when a message comes in, it can be
passed automatically to a callback that you previously specified.

It also gives clients another way of sending a message and waiting for
the reply: using a coroutine. For example

    async def request_reply(connection) :
        message = dbussy.Message.new_method_call(...)
        ... other setup of message args etc ...
        reply = await connection.send_await_reply(message, timeout)
        ... process reply ...
    #end request_reply

    loop = asyncio.get_event_loop()
    dbus_task = loop.create_task(request_reply(connection))
    ... maybe create other tasks to run while awaiting reply ...
    loop.run_until_complete(dbus_task)

On the server side, you can correspondingly use coroutines to handle
time-consuming requests without blocking the main loop. A message
filter or object-path message callback can return, instead of
DBUS.HANDLER_RESULT_HANDLED, a coroutine. The wrapper code will give
libdbus a result of DBUS.HANDLER_RESULT_HANDLED on your behalf, after
creating a task to execute the coroutine on the event loop. The
coroutine can then go on to handle the actual processing of the
request, and return the reply at some later stage.


DBussy Examples
===============

Sample code illustrating how to use DBussy is available in my
dbussy_examples repo on GitLab <https://gitlab.com/ldo/dbussy_examples>
and GitHub <https://github.com/ldo/dbussy_examples>.


How Do You Pronounce “DBussy”?
==============================

The name is a pun on “dbus” and the name of French Impressionist
composer Claude Debussy. The most natural way to pronounce it would be
the same as his name. At least, that’s my story, and I’m sticking to
it.


Lawrence D'Oliveiro <ldo@geek-central.gen.nz>
2017 April 30
