DBussy is yet another Python binding for accessing D-Bus
<https://www.freedesktop.org/wiki/Software/dbus/>. I know there is
already dbus-python <http://dbus.freedesktop.org/doc/dbus-python/>,
among others
<https://www.freedesktop.org/wiki/Software/DBusBindings/>. So why do
we need another one?

The main issue is one of event loops. Most of the existing bindings
seem to be based around GLib. However, Python now has its own
“asyncio” event-loop architecture
<https://docs.python.org/3/library/asyncio.html>. This goes back to
Python 3.4, but as of 3.5, you now have full-fledged coroutines
(“async def” and “await”) as a language feature.

Every GUI toolkit already provides its own event loop; so why did
the Python developers decide to add yet another one? The answer
seems clear: to provide a language-standard API for event loops,
and a reference implementation for this API. It should be possible
to adapt other event loops to this same API, and then Python
code written to work with asyncio becomes event-loop agnostic.


What Is D-Bus?
==============

D-Bus is a high-level interprocess communication protocol. It also
provides a standard daemon, that is included with the main Linux
desktop environments, that implements a set of standard “buses”: a
“system” bus that is created at system boot time, and a “session” bus
that belongs to each user who logs into one of these desktop
environments.

Processes can register their services on one of these buses--the
system bus for systemwide access, or the session bus for per-user
access--where other processes can find them by name and connect to
them. Or they can accept connections on entirely separate networking
sockets, without any dependency on the D-Bus daemon. libdbus, the
reference implementation for the low-level D-Bus protocol, supports
both modes of operation.

D-Bus is based around the concept of passing messages conforming to
a standard, extensible format. Messages are of four types:
  * a “method call”
  * a “method return” (normal response to a method call)
  * an “error” (abnormal response to a method call)
  * a “signal” notification

A method-call message is how one process requests a service of another
process via D-Bus; the usual response would be a method-return message
in the other direction indicating the completion status of the service
being performed; it is also possible to send method-call messages
without expecting a reply. If there was something wrong with the
method-call message (e.g. inappropriate parameters, lack of
permissions), then the response would be an error message. One could
also send a method-return with information indicating a failure to
perform the requested service; presumably the choice between the types
of response is that an error return indicates a condition that is not
supposed to happen--a bug in the requesting program.

Signal messages are sent as notifications of interesting events
pertaining to the current session (for the session bus) or the entire
system (for the system bus). They are usually not sent to a specific
destination, but can be picked up by all interested processes on the
bus. There are no replies to signals; if the receiving process cannot
or will not process a particular message, it simply ignores it.

Messages optionally include the following information:
  * a destination “bus name” indicating the process that is to
    receive the message (this is not the name of the bus, but the
    name of a process on the bus)
  * an “object path” which looks like a POSIX absolute file name
    (always beginning with a slash and never ending with a slash);
    the meaning of this is up to the receiving process, but it is
    intended to indicate some object within the hierarchy exposed
    by the process
  * an “interface name” which identifies the particular message
    protocol
  * a “method name” which identifies the particular function to be
    performed within that interface.

Bus names and interface names look like domain names with the components
reversed, so the top level is at the beginning. If you are familiar with
package names in Java, they take the same form, and with the same
intent: to reduce the chance of name conflicts.

D-Bus defines some standard interfaces which are meant to be
understood by most if not all services. For example, the
“org.freedesktop.DBus.Introspectable” interface defines an
“Introspect” method; the expected response to this is an XML string
that describes all the interfaces understood by the object identified
by the object path, as well as listing all the available child objects
that can be accessed by appending a slash and the child name to the
parent object path, if any.

D-Bus also includes an extensive, but not extensible, type system for
encoding data in a message. This data represents arguments to the
method call or signal, return results for a method return or the error
name and message for an error. A message contains a sequence of 0, 1
or more items of such data, each of which can be of various types:
“basic” types (e.g. integer, float, string) or “container” types
(structs, arrays, dictionaries) which in turn contain more values,
each of which in turn can be of a basic or (recursively) another
container type. A “signature” is a string encoding the type of a
value, or sequence of values; there is also a “variant” type, which
means the type of the value is encoded dynamically with the value
itself, separate from the signature.

The importance of type signatures is really up to the particular
programs that are trying to communicate: some might insist on values
exactly matching the expected type signature, whereas others might be
more lenient. For example, while the D-Bus type system specifies
different basic types for different sizes of integers of signed or
unsigned varieties, most Python code will probably not care about the
specific distinctions, and treat all these values as of type “int”.


Enter DBussy
============

DBussy allows you to take advantage of asyncio, but it doesn’t force
you to use it. DBussy is meant to give you access to (nearly) all the
functionality of the underlying libdbus library
<https://dbus.freedesktop.org/doc/api/html/index.html>. libdbus is a
very low-level, very general library, designed to be called from C
code, that makes no assumptions about event loops at all. Consider the
basic task in a client program of sending a D-Bus request message and
waiting for a reply; or consider a server waiting for a message to
come in. libdbus offers 3 different ways to handle this:

  * poll repeatedly until the message appears
  * block the thread until the message comes in
  * specify a callback to be notified when the message is available

DBussy offers access to all these ways. But it also gives you the
option of engaging the asyncio event loop. This means you can be doing
other things in the loop, and when a message comes in, it can be
passed automatically to a callback that you previously specified.

It also gives clients another way of sending a message and waiting for
the reply: using a coroutine. For example

    async def request_reply(connection) :
        message = dbussy.Message.new_method_call(...)
        ... other setup of message args etc ...
        reply = await connection.send_await_reply(message, timeout)
        ... process reply ...
    #end request_reply

    loop = asyncio.get_event_loop()
    dbus_task = loop.create_task(request_reply(connection))
    ... maybe create other tasks to run while awaiting reply ...
    loop.run_until_complete(dbus_task)

On the server side, you can correspondingly use coroutines to handle
time-consuming requests without blocking the main loop. A message
filter or object-path message callback can return, instead of
DBUS.HANDLER_RESULT_HANDLED, a coroutine. The wrapper code will give
libdbus a result of DBUS.HANDLER_RESULT_HANDLED on your behalf, after
creating a task to execute the coroutine on the event loop. The
coroutine can then go on to handle the actual processing of the
request, and return the reply at some later stage.

The dbussy module also offers several more Pythonic facilities beyond
those of the underlying libdbus, including a higher-level
representation of type signatures as Type objects (and subclasses
thereof), and an Introspection object hierarchy that can be easily
converted to and from the standard D-Bus introspection XML
representation.


Ravel: The Higher-Level Interface
=================================

Rather than directly manipulating D-Bus message objects, it can often
be more convenient to have a representation where D-Bus object paths
are directly mapped to Python objects, and D-Bus method calls are
similarly mapped to calls on methods of those Python objects.

Such a representation is provides by the “ravel” module. It actually
defines two such representations: a more ad-hoc one, suitable for
client use, where object and interface references are constructed
on-the-fly, and a more structured one where interfaces have to be
defined and registered with a bus connection, so that their methods
can be automatically invoked in response to incoming messages. The
latter can be used by servers to receive and respond to method calls,
and by clients to handle signals.

Both systems start by creating a ravel.Connection object, which is a
wrapper around a lower-level dbussy.Connection object. You can get one
for the session or system bus by calling ravel.session_bus() and
ravel.system_bus() respectively, or you can use a ravel.Server object
(wrapping around the corresponding dbussy.Server) to accept
connections on your own network address, separate from the D-Bus
daemon.


Ad-Hoc Higher-Level Calls
-------------------------

The basic method for using these calls, having obtained a connection
«bus», and wanting to access an object path «path» at a bus name «bus_name»,
is to get a reference to the bus object with

    «bus».get_object(«bus_name», «path»)

which returns a ravel.CObject object, which I will refer to as
«object». From this, you get a reference to the particular interface
named «interface_name» you want to access with
«object».get_interface(«interface_name»), which returns a
ravel.CInterface object «interface» which has automatically
introspected the interface on that bus name to obtain information on
the valid methods to call. Then you can call a method named «method»
on this object exactly as though it were a Python object.

Or, you can put it all together in a single Python expression if you
have no need to reuse any of the intermediate objects, thus:

    «bus».get_object(«bus_name», «path») \
        .get_interface(«interface_name») \
        .«method»(«args»)

If the method call returns a result (as defined by its introspection
signature), then the above Python expression returns that result,
which can then be assigned to a variable or otherwise processed in all
the usual ways.

Note that the method result is always a list.

The above is a *blocking* call, which means the current thread is
blocked while waiting for the reply to the method call. If you want to
do things in a more event-loop-friendly fashion, then use the
get_async_interface of the CObject instead of get_interface, which
returns a coroutine object that yields a CAsyncInterface object when
it finally completes. Method calls on this are automatically also
coroutine calls, so you can use them in await-constructs in your
coroutines, or create asyncio tasks to run them etc.


Structured Interface Definitions
--------------------------------

The more structured high-level interface offered by Ravel is built
around the concept of an *interface class*, which is a Python class
that you define to implement a D-Bus interface. You can then
register instances of this class on a bus connection at selected
points in your object path hierarchy, to handle either only specific
objects at those paths or as a fallback to also deal with objects
at points below those, that do not have their own instance of this
class registered.

An interface class is identified by applying the @ravel.interface()
decorator to the class definition, specifying the kind of interface
(for use client-side, server-side or both), and the interface name, e.g.

    @ravel.interface(ravel.INTERFACE.SERVER, name = "com.example.my_interface")
    class MyClass :
        ...
    #end MyClass

Within such a class, Python methods that are to handle D-Bus method
calls are identified with the @ravel.method() decorator, e.g.:

    @ravel.method \
      (
        name = ...,
        in_signature = ...,
        out_signature = ...,
        args_keyword = ...,
        arg_keys = ...,
        arg_attrs = ...,
        result_keyword = ...,
        result_keys = ...,
        result_attrs = ...,
        connection_keyword = ...,
        message_keyword = ...,
        path_keyword = ...,
        bus_keyword = ...,
        set_result_keyword = ...,
        ...
      )
    def my_method(...) :
        ...
    #end my_method

As you can see, there are a large number of options for implementing
such a method. It can also be defined as a coroutine with async def if
you have an event loop attached, and Ravel will automatically queue
the task for execution and await any returned result. Partial summary
of arguments:
  * name -- the D-Bus method name. If omitted, defaults to the Python
    function name.
  * in_signature -- the D-Bus signature specifying the arguments (zero or more)
    to the method.
  * out_signature -- the D-Bus signature specifying the results (zero
    or more) the method will return.
  * args_keyword -- the name of an argument to the Python function that will
    be set to the arguments from the message method call. The arguments
    will be passed as a list, or a dict, or an attributed class, depending the
    specification of arg_keys and arg_attrs (see below).
  * path_keyword -- if specified, then the object path field from the
    incoming method call will be passed to the Python function as the
    value of the argument with this name.
  * message_keyword -- if specified, then the dbussy.Message object
    for the incoming method call will be passed to the Python function
    as the value of the argument with this name.
  * connection_keyword -- if specified, then the dbussy.Connection object
    will be passed to the Python function as the value of the argument
    with this name.
  * bus_keyword -- if specified, then the ravel.Connection object
    will be passed to the Python function as the value of the argument
    with this name.
  * set_result_keyword -- if specified, then a function of a single
    argument will be passed to the Python function as the value of the
    argument with this name; the argument passed by calling this
    function becomes the method result.

Passing arguments: the argument with the name given by args_keyword
will hold the extracted arguments from the method call message. If
neither of arg_keys or arg_attrs is specified, then the arguments are
passed as a list. If arg_keys is specified, then it must be a sequence
of names that must match the number of types specified by the
in_signature; in this case, the args will be passed as a dict with the
keys given in arg_keys associated in order with the argument values.

If arg_attrs is specified instead of arg_keys, then it must be a
sequence of names that must match the number of types specified by the
in_signature; a mutable attributed class object is created by calling
ravel.def_attr_class, with the attribute names taken from arg_keys
assigned in order to the argument values.

Returning results: the function can return the result values to be
inserted into the method-return message as the function result, by
assigning to elements of a mutable result argument (passed as the
argument named by result_keyword, or by calling the set_result
function that was passed via the set_result_keyword (above); the last
method is not currently available to coroutines.

If neither result_keys nor result_attrs is specified, then the result
is expected to be a sequence of values matching the out_signature. If
it is returned as the function result, then it can be a tuple or list;
but if result_keyword is specified, then the value of this is a list,
and the values in the sequence must be assigned to the elements of
this list in-place.

If result_keys is specified, then the result is a dict mapping the
names from result_keys to the values of the result sequence in order.
If result_attrs is specified, then the result is a mutable attributed
class object created by calling ravel.def_attr_class, mapping the
names from result_attrs to the values of the result sequence in order.
If result_keyword is not specified, then the result object is expected
to be returned as the function result; otherwise, it is passed as the
value of the argument named by result_keyword, and the handler is
supposed to update its elements in-place.


DBussy Examples
===============

Sample code illustrating how to use DBussy/Ravel is available in my
dbussy_examples repo on GitLab <https://gitlab.com/ldo/dbussy_examples>
and GitHub <https://github.com/ldo/dbussy_examples>.


How Do You Pronounce “DBussy”?
==============================

The name is a pun on “dbus” and the name of French Impressionist
composer Claude Debussy. The most natural way to pronounce it would be
the same as his name. At least, that’s my story, and I’m sticking to
it.


Lawrence D'Oliveiro <ldo@geek-central.gen.nz>
2017 May 14
